#include "Fusion.h"

Fusion::Fusion(){
    interp = 0;
    opacity = 0.1;
    scale = 200;
    displace = 0;
    x0 = y0 = z0 = 0;
    x1 = y1 = z1 = 0;
    
    scanX = scale;
    scanY = scale;
    scanHeight = 40;
    scanWidth = 0;
    scanRate = 0;
    runScan = 0;
}

Fusion::~Fusion() {}

void Fusion::load(std::string path0, std::string path1, int n) {
    plyLoader ply0(path0);
    plyLoader ply1(path1);
    
    w = h = std::sqrt(n/3);
    
    meshGen(&ply0, &m0, &f0, &norm0);
    meshGen(&ply1, &m1, &f1, &norm1);
    
    shader.load("shaders/draw");
}

void Fusion::meshGen(plyLoader *ply, ofVboMesh *mesh, ofFbo *fbo, ofFbo *norm) {
    std::vector<float>* pv = ply->get_verts();
    std::vector<float>* nv = ply->get_norms();
    std::vector<float>::iterator it = pv->begin();
    std::vector<float>::iterator it_norm = nv->begin();
    
    mesh->clear();

    float scale = 1.0;
    it = pv->begin();
    float pxtotal = 0;
    float *positions = new float[w * h * 4];
    float *normals   = new float[w * h * 4];
    
    bool has_norms = (nv->size() != 0);
    
    for (unsigned y = 0; y < h; ++y) {
        for (unsigned x = 0; x < w; ++x) {
            float px, py, pz, nx, ny, nz;
            if (it != pv->end()){
                px = (*it); it++;
                py = (*it); it++;
                pz = (*it); it++;
                
                if (has_norms) {
                    nx = (*it_norm); it_norm++;
                    ny = (*it_norm); it_norm++;
                    nz = (*it_norm); it_norm++;
                }
            } else {
                px = py = pz = 0;
                nx = ny = nz = 0;
            }
            
            unsigned idx = y * w + x;
            positions[idx * 4 + 0] = px*scale; // particle x
            positions[idx * 4 + 1] = py*scale; // particle y
            positions[idx * 4 + 2] = pz*scale; // particle z
            positions[idx * 4 + 3] = 0;
            
            normals[idx * 4 + 0] = nx; // particle x
            normals[idx * 4 + 1] = ny; // particle y
            normals[idx * 4 + 2] = nz; // particle z
            normals[idx * 4 + 3] = 0;
            
            mesh->addVertex(ofVec3f(0,0));
            mesh->addTexCoord(ofVec2f(x, y));
        }
        
    }
    
    mesh->setMode(OF_PRIMITIVE_POINTS);
    
    ofFbo::Settings s;
    s.internalformat = GL_RGBA32F_ARB;
    s.textureTarget = GL_TEXTURE_RECTANGLE_ARB;
    s.minFilter = GL_NEAREST;
    s.maxFilter = GL_NEAREST;
    s.wrapModeHorizontal = GL_CLAMP;
    s.wrapModeVertical = GL_CLAMP;
    s.width = w;
    s.height = h;
    
    fbo->clear();
    fbo->allocate(s);
    
    norm->clear();
    norm->allocate(s);
    
    fbo->getTexture().bind();
    glTexSubImage2D(GL_TEXTURE_RECTANGLE_ARB, 0, 0, 0, w, h, GL_RGBA, GL_FLOAT, positions);
    fbo->getTexture().unbind();
    
    norm->getTexture().bind();
    glTexSubImage2D(GL_TEXTURE_RECTANGLE_ARB, 0, 0, 0, w, h, GL_RGBA, GL_FLOAT, normals);
    norm->getTexture().unbind();
    
    delete[] positions;
    delete[] normals;
}

void Fusion::setInterp(float _interp) { interp = _interp; }
void Fusion::setOpacity(float _opacity) { opacity = _opacity; }
void Fusion::setScale(float _scale) { scale = _scale; }
void Fusion::setDisplacement(float _displace) { displace = _displace; }

void Fusion::setScanX(float width, float rate, int run) {
    runScan = run;
    scanWidth = width;
    scanRate = rate;
}

void Fusion::setScanY(float height, float rate, int run) {
    runScan = run;
    scanHeight = height;
    scanRate = rate;
}

void Fusion::setPos0(float x, float y, float z) { x0 = x; y0 = y, z0 = z; }
void Fusion::setPos1(float x, float y, float z) { x1 = x; y1 = y, z1 = z; }

void Fusion::setDof(ofPoint _cam, ofPoint _dof, float _bell) {
    cam = _cam;
    dofCenter = _dof;
    bell = _bell;
}

void Fusion::update(){
    if (runScan) {
        scanY = (scanY - scanRate);
        if (scanY < 0) scanY = scale;
//        scanX = (scanX - scanRate);
//        if (scanX < 0) scanX = scale;
    }
}

void Fusion::draw(){
    shader.begin();
    shader.setUniformTexture("tex0", f0.getTexture(), 0);
    shader.setUniformTexture("tex1", f1.getTexture(), 1);
    shader.setUniformTexture("tex2", norm0.getTexture(), 2);
    shader.setUniformTexture("tex3", norm1.getTexture(), 3);
    
    shader.setUniform1f("scale", scale);
    shader.setUniform1f("opacity", opacity);
    
    shader.setUniform1f("interp", interp);
    shader.setUniform1f("displace", displace);
    
//    shader.setUniform1f("scanX", scanX);
    shader.setUniform1f("scanY", scanY);
//    shader.setUniform1f("scanWidth", scanWidth);
    shader.setUniform1f("scanHeight", scanHeight);
    shader.setUniform1i("runScan", runScan);
    shader.setUniform1i("wrapScan", 1);
    
    shader.setUniform4f("pos0", ofVec4f(x0, y0, z0, 0));
    shader.setUniform4f("pos1", ofVec4f(x1, y1, z1, 0));
    
    shader.setUniform4f("cam", cam.x, cam.y, cam.z, -cam.dot(dofCenter) * scale);
    shader.setUniform1f("bell", bell);

    m0.draw();
    shader.end();
}
